// Generated by LiveScript 1.2.0
(function(){
  var cluster, EE, os, childProcess, numCpus, slice$ = [].slice;
  cluster = require('cluster');
  EE = require('events').EventEmitter;
  os = require('os');
  childProcess = require('child_process');
  numCpus = os.cpus().length;
  module.exports = new (function(superclass){
    var prototype = extend$(import$(constructor, superclass), superclass).prototype;
    function constructor(){
      var this$ = this;
      constructor.superclass.call(this);
      if (cluster.isMaster) {
        this.side = 'master';
      } else if (cluster.isWorker) {
        this.side = 'worker';
      }
      cluster.on('exit', function(){
        var args;
        args = slice$.call(arguments);
        return this$.emit.apply(this$, ['exit'].concat(slice$.call(args)));
      });
      console.log(this);
    }
    prototype.send = function(chan, msg){
      if (this.side !== 'worker') {
        throw new Error('Can only send messages from workers');
      }
      return process.send({
        chan: chan,
        msg: msg
      });
    };
    prototype.spawn = function(num){
      var i$, i;
      num == null && (num = numCpus);
      for (i$ = 1; i$ <= num; ++i$) {
        i = i$;
        this.spawnWorker();
      }
      return this;
    };
    prototype.spawnWorker = function(){
      var worker, this$ = this;
      worker = cluster.fork();
      worker.on('message', function(arg$){
        var chan, msg;
        chan = arg$.chan, msg = arg$.msg;
        return this$.emit("message:" + chan, worker, msg);
      });
      this.emit('worker', worker);
      return worker;
    };
    prototype.killall = function(sym){
      var id, ref$, worker;
      for (id in ref$ = cluster.workers) {
        worker = ref$[id];
        worker.kill(sym);
      }
      return this;
    };
    prototype.reload = function(full){
      var num;
      num = cluster.workers.length;
      this.killall('SIGQUIT');
      if (full) {
        this.emit('stop');
        childProcess.fork(require.main.filename, process.argv);
        return process.exit(0);
      } else {
        return this.spawn(num);
      }
    };
    prototype.use = function(plugin){
      plugin(this);
      return this;
    };
    prototype.watch = require('./watch');
    return constructor;
  }(EE));
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
